Verifying property 1 at line 1 control: A<>pm.finish

Property is satisfied.
$v_gameInfoPlayInitial state:
( seconda.start prima.start pm.start ) 
(plan_clock==R1_clock && R1_clock==seconda.seconda_clock && seconda.seconda_clock==prima.prima_clock && prima.prima_clock==pm.pm_clock && pm.pm_clock==0)

Strategy to win:

State: ( seconda.start prima.start pm.pm9 ) 
When you are in (plan_clock==100 && plan_clock==R1_clock && R1_clock==100), take transition pm.pm9->pm.finish { plan_clock >= 100 && pm_clock >= 0, tau, 1 }
While you are in	(10<=plan_clock && plan_clock<100 && plan_clock==R1_clock), wait.

State: ( seconda.start prima.start pm.start ) 
When you are in (plan_clock==R1_clock && R1_clock==pm.pm_clock && pm.pm_clock==0), take transition pm.start->pm.pm1 { plan_clock == 0, tau, 1 }

State: ( seconda.start prima.start pm.pm1 ) 
While you are in	(plan_clock<10 && plan_clock==R1_clock && R1_clock==pm.pm_clock && pm.pm_clock==plan_clock), wait.
When you are in (10<=plan_clock && 10<=pm.pm_clock && plan_clock<=20 && plan_clock==R1_clock && pm.pm_clock<=20), take transition pm.pm1->pm.pm9 { plan_clock >= 10 && pm_clock >= 10, tau, pm_clock := 0 }
====================================

Verifying property 2 at line 2 control: A<>prima.finish
Property is satisfied.
$v_gameInfoPlayInitial state:
( seconda.start prima.start pm.start ) 
(plan_clock==R1_clock && R1_clock==seconda.seconda_clock && seconda.seconda_clock==prima.prima_clock && prima.prima_clock==pm.pm_clock && pm.pm_clock==0)

Strategy to win:

State: ( seconda.start prima.start pm.start ) 
When you are in (plan_clock==R1_clock && R1_clock==pm.pm_clock && pm.pm_clock==0), take transition prima.start->prima.prima1 { plan_clock == 0, tau, 1 }

State: ( seconda.start prima.prima1 pm.start ) 
While you are in	(plan_clock<=80 && plan_clock==R1_clock && R1_clock==pm.pm_clock && pm.pm_clock==plan_clock), wait.

State: ( seconda.start prima.prima2 pm.start ) 
While you are in	(200<=R1_clock && 20<pm.pm_clock && plan_clock<100 && plan_clock-R1_clock<=-120 && R1_clock-plan_clock<=150), wait.
When you are in (plan_clock==100 && 200<R1_clock && 20<pm.pm_clock), take transition prima.prima2->prima.finish { plan_clock >= 100, tau, 1 }

========================================================
Verifying property 3 at line 3 control: A<>seconda.finish
Property is NOT satisfied.
$v_gameInfoCounterPlayInitial state:
( seconda.start prima.start pm.start ) 

(plan_clock==R1_clock && R1_clock==seconda.seconda_clock &&
seconda.seconda_clock==prima.prima_clock &&
prima.prima_clock==pm.pm_clock && pm.pm_clock==0)

Counter strategy to prevent from winning:

State: ( seconda.start prima.start pm.start ) 

While you are in (plan_clock==R1_clock && R1_clock==pm.pm_clock &&
pm.pm_clock==plan_clock), wait. 
Cioe' aspetta finche' non si muove pm da pm1 a pm9, dove resetta pm_clock
Ma la transizione da seconda.start a seconda.seconda1 e'
controllabile, e lo stesso per prima.start. E devono avvenire quando
plan_clock=0 ?



State: ( seconda.start prima.start pm.pm9 ) 

While you are in (10<=plan_clock && plan_clock<=100 &&
plan_clock==R1_clock), wait.


State: ( seconda.seconda1 prima.prima1 pm.pm9 ) 

While you are in (10<=plan_clock && plan_clock<50 &&
plan_clock==R1_clock), wait.

When you are in (50<=plan_clock && plan_clock<80 &&
plan_clock==R1_clock), take transition prima.prima1->prima.prima2 {
plan_clock >= 50 && prima_clock >= 0, tau, prima_clock := 0, R1_clock
:= H }

State: ( seconda.seconda1 prima.prima1 pm.start ) 

While you are in (plan_clock<50 && plan_clock==R1_clock &&
R1_clock==pm.pm_clock && pm.pm_clock==plan_clock), wait.

When you are in (50<=plan_clock && plan_clock<80 &&
plan_clock==R1_clock && R1_clock==pm.pm_clock &&
pm.pm_clock==plan_clock), take transition prima.prima1->prima.prima2 {
plan_clock >= 50 && prima_clock >= 0, tau, prima_clock := 0, R1_clock
:= H }

State: ( seconda.start prima.prima1 pm.pm1 ) 

While you are in (plan_clock<=20 && plan_clock==R1_clock &&
R1_clock==pm.pm_clock && pm.pm_clock==plan_clock), wait.

State: ( seconda.start prima.prima2 pm.finish ) 

While you are in (plan_clock==100 && 200<R1_clock), wait.

State: ( seconda.seconda1 prima.start pm.start ) 

While you are in (plan_clock<=80 && plan_clock==R1_clock &&
R1_clock==pm.pm_clock && pm.pm_clock==plan_clock), wait.

State: ( seconda.start prima.prima1 pm.start ) 

While you are in (plan_clock<50 && plan_clock==R1_clock &&
R1_clock==pm.pm_clock && pm.pm_clock==plan_clock), wait.

When you are in (50<=plan_clock && plan_clock<=80 &&
plan_clock==R1_clock && R1_clock==pm.pm_clock &&
pm.pm_clock==plan_clock), take transition prima.prima1->prima.prima2 {
plan_clock >= 50 && prima_clock >= 0, tau, prima_clock := 0, R1_clock
:= H }

State: ( seconda.start prima.start pm.pm1 ) 

While you are in (plan_clock<=20 && plan_clock==R1_clock &&
R1_clock==pm.pm_clock && pm.pm_clock==plan_clock), wait.

State: ( seconda.start prima.prima2 pm.pm9 ) 

While you are in (200<=R1_clock && plan_clock<=100 &&
plan_clock-R1_clock<=-120 && R1_clock-plan_clock<=150), wait.

State: ( seconda.seconda1 prima.start pm.pm9 ) 

While you are in (10<=plan_clock && plan_clock<=80 &&
plan_clock==R1_clock), wait.

State: ( seconda.start prima.finish pm.pm9 ) 

While you are in (plan_clock==100 && 200<R1_clock), wait.

State: ( seconda.start prima.prima2 pm.start ) 

While you are in (200<=R1_clock && 20<pm.pm_clock && plan_clock<=100
&& plan_clock-R1_clock<=-120 && R1_clock-plan_clock<=150), wait.

State: ( seconda.seconda1 prima.start pm.pm1 ) 

While you are in (plan_clock<=20 && plan_clock==R1_clock &&
R1_clock==pm.pm_clock && pm.pm_clock==plan_clock), wait.

State: ( seconda.seconda1 prima.prima2 pm.start ) 

While you are in (200<=R1_clock && 20<pm.pm_clock && plan_clock<=80 &&
plan_clock-R1_clock<-120 && R1_clock-plan_clock<=150), wait.

State: ( seconda.start prima.finish pm.start ) 

While you are in (100<=plan_clock && 200<R1_clock &&
plan_clock-pm.pm_clock<80), wait.

State: ( seconda.seconda1 prima.prima2 pm.pm9 ) 

While you are in (200<=R1_clock && plan_clock<=80 &&
plan_clock-R1_clock<-120 && R1_clock-plan_clock<=150), wait.

State: ( seconda.start prima.prima1 pm.pm9 ) 

While you are in (10<=plan_clock && plan_clock<50 &&
plan_clock==R1_clock), wait.

When you are in (50<=plan_clock && plan_clock<=80 &&
plan_clock==R1_clock), take transition prima.prima1->prima.prima2 {
plan_clock >= 50 && prima_clock >= 0, tau, prima_clock := 0, R1_clock
:= H }

State: ( seconda.start prima.start pm.finish ) 

While you are in (100<=plan_clock && plan_clock==R1_clock), wait.

State: ( seconda.seconda1 prima.prima1 pm.pm1 ) 

While you are in (plan_clock<=20 && plan_clock==R1_clock &&
R1_clock==pm.pm_clock && pm.pm_clock==plan_clock), wait.

State: ( seconda.start prima.finish pm.finish ) 

While you are in (100<=plan_clock && plan_clock-R1_clock<-100), wait.

=================== con opzioni -w0 e -c0: ==========================

Fa solo la transizione prima.prima1->prima.prima2 

state:
( seconda.start prima.start pm.start ) 

(plan_clock==R1_clock && R1_clock==seconda.seconda_clock &&
seconda.seconda_clock==prima.prima_clock &&
prima.prima_clock==pm.pm_clock && pm.pm_clock==0)

Counter strategy to prevent from winning:

State: ( seconda.seconda1 prima.prima1 pm.start ) 

When you are in (50<=plan_clock && plan_clock<80 &&
plan_clock==R1_clock && R1_clock==pm.pm_clock &&
pm.pm_clock==plan_clock), take transition prima.prima1->prima.prima2 {
plan_clock >= 50 && prima_clock >= 0, tau, prima_clock := 0, R1_clock
:= H }

State: ( seconda.start prima.prima1 pm.pm9 ) 

When you are in (50<=plan_clock && plan_clock<=80 &&
plan_clock==R1_clock), take transition prima.prima1->prima.prima2 {
plan_clock >= 50 && prima_clock >= 0, tau, prima_clock := 0, R1_clock
:= H }

State: ( seconda.seconda1 prima.prima1 pm.pm9 ) 

When you are in (50<=plan_clock && plan_clock<80 &&
plan_clock==R1_clock), take transition prima.prima1->prima.prima2 {
plan_clock >= 50 && prima_clock >= 0, tau, prima_clock := 0, R1_clock
:= H }

State: ( seconda.start prima.prima1 pm.start ) 

When you are in (50<=plan_clock && plan_clock<=80 &&
plan_clock==R1_clock && R1_clock==pm.pm_clock &&
pm.pm_clock==plan_clock), take transition prima.prima1->prima.prima2 {
plan_clock >= 50 && prima_clock >= 0, tau, prima_clock := 0, R1_clock
:= H }

